# #1. 최댓값을 하나씩 돌면서 갱신
# A = list(map(int, input().split()))

# k=0
# for i in range(len(A)-1):
#   if A[i] > A[i+1]:
#     k=len(A)-1-i
#     break
# print(k)

# #간단히 처음부터 하나씩 보면서 오름차순 정렬이 되어있지 않은 부분을 찾았다.
# #그 후 해당 인덱스를 A의 마지막 인덱스에서 뺐다. 그만큼이 원래 오름차순 정렬에서 rotation이동을 한 값이다. O(n)

#2. 최댓값을 이진탐색으로 탐색
#f, m, l의 3개의 값을 기준으로 구분하며 탐색범위를 매번 반으로 줄일 수 있다.
A = list(map(int, input().split()))

#Slicing을 이용하지 않고 비재귀적으로 이진 탐색
def RBS(A):
  f=0
  l = len(A)-1
  if A[f]<A[l]: #최대값이 맨 우측 따라서 rotate 없음
    return l
  #무조건 rotate 한경우만 반복문으로 따짐
  while f < l:
    m = (f+l)//2
    #print(f, m, r)
    if A[f]<A[m]: #처음부터 중간이 오름차순
      f = m
    elif A[m]<A[l]:#A[l]: #중간부터 끝이 오름차순
      l = m
    else:
      return f

k=len(A)-1-RBS(A)
print(k)

#여기서 특이한 점은 A[l]이 아닌 A[l-1]로 해도 된다는 것이다.
#아래처럼 3,4, 5개의 모든 경우를 통해서 살펴보면
# 1 2 3
# 바로 나옴

# 2 3 1
# 2 3이 오름차순이라
#   3 1을 봄
# 어떤 조건도 해당하지 않아 3

# 2 3 이 오름차순이라
#   3을 봄
# 어떤 조건도 해당하지 않아 3

# 3 1 2
# 1 2 오름차순이라
# 3 1을 봄
# 어떤 조건도 해당하지 않아 3

# r-1시 조건 다 성립하지 않아 바로 3 나옴

# 1 2 3 4
# 바로 나옴

# 2 3 4 1
# 2 3 오름차순이라
#   3 4 1 봄 (4 1을 보면 안됨)

# 2 3 오름차순이라
#   3 4 봄
#   3 4 오름차순이라
# 4 봄
# 어떤 조건도 해당하지 않아 4

# 3 4 1 2
# 3 4 오름차순이라
#   4 1 2 봄 (1 2만 보면 안됨)
# 1 2 오름차순이라
#   4 1 봄
# 어떤 조건도 해당하지 않아 4 나옴

# 3 4 오름차순이라
#   4 1 봄
# 어떤 조건도 해당하지 않아 4 나옴

# 4 1 2 3
# 1 2 3 오름차순이라
# 4 1 봄
# 어떤 조건도 해당하지 않아 4나옴

# 1 2 오름차순이라
# 4 1 봄
# 어떤 조건도 해당하지 않아 4 나옴

# 1 2 3 4 5
# 바로 나옴

# 2 3 4 5 1
# 2 3 4 오름차순이라
#     4 5 1 나옴
#     4 5 오름차순이라
#       5 1 나옴
# 따라서 조건에 없어 5

# 2 3 4 오름차순이라
#     4 5 나옴
#     4 5 오름차순이라
#       5 나옴
# 따라서 조건에 없어 5

# 3 4 5 1 2
# 3 4 5 오름차순이라
#     5 1 2 나옴
#       1 2 오름차순이라
#     5 1 나옴
# 따라서 조건에 없어 5

# 3 4 5 오름차순이라
#     5 1 나옴
# 따라서 조건에 없어 5

# 4 5 1 2 3
#     1 2 3 오름차순이라 
# 4 5 1 나옴
# 4 5 오름차순이라
#   5 1 나옴
# 따라서 조건에 없어 5

#     1 2 오름차순이라 
# 4 5 1 나옴
# 4 5 오름차순이라
#   5 나옴
# 따라서 조건에 없어 5

# 5 1 2 3 4
#     2 3 4 오름차순이라
# 5 1 2나옴
#   1 2 오름차순이라
# 5 1 나옴
# 따라서 조건에 없어 5

#     2 3 오름차순이라
# 5 1 2나옴
# 따라서 조건에 없어 5

#먼저 rotate를 하지 않는 것은 제외하고 while문에서는 rotate가 존재하는 리스트만 존재한다.
#따라서 if문에서 먼저 앞에서 중간까지 오름차순인지 확인하고 맞다면 처음범위를 중간범위로 설정한다.
#만약 앞에서 중간까지 오름차순이 아니라면 그 다음 조건을 확인하는데 거기서 마지막 값이 가장 클 경우는 이미 배제 되었으므로 앞의 기본 예시처럼 항상 f값을 가지고 생각해도 된다.


#하지만 반반씩 나눠서 본다는 의미에 맞도록 A[l]기준으로 알고리즘의 비교 횟수를 분석한 후 Big-O시간으로 표기하겠다.
#비재귀형태로 인덱스를 수정하여 값을 도출해내었다.
#먼저 rotate없을 때를 따로 계산했다.
#그 후 중간값을 기준으로 좌우측의 값과 비교하여 오름차순이 아닌 부분을 본다. 그러다보면 f와 m의 중간값이 같아져서 A[f]의 값보다 A[m]이 크지 않고 A[m]보다 A[l]의 크기가 크지 않은 오름차순이 아닌 부분, 즉 f가 최댓값을 가리키고 있는 인덱스이므로 그 값을 기준으로 len(A)-1-RBS(A)로 찾은 최대값을 기준으로 rotate가 몇번 되어있는 지 알아낸다. 단 여기서는 이진탐색과 다르게 중간값과 좌우측 값을 비교하는 것이므로 반으로 줄일 때 중간값을 제거하지 않는다!
#따라서 while문을 돌 때마다 전체중 대략 반이 줄어들기 때문에 수행시간은 T(n)=T(n/2)+c이므로 O(logn)이다.















# def Find_Rotate(A, f, l):
#   m = (f+l)//2 #중간값부터 탐색
#   print("fml", f, m, l)
#   if A[f] < A[l-1]: #f<l인 한가지 경우
#     return 0 #k값을 0으로 하는 인덱스를 반환
#   elif A[m] < A[l-1]: #m<l<F의 경우
#     return Find_Rotate(A, f, m)
#   elif A[f] < A[m]: #l<f<m의 경우
#     return Find_Rotate(A, m, l)
#   else: 
#     return len(A)-f-1
  
# #중간 값을 기준으로 탐색

# k=Find_Rotate(A, 0, len(A))
# print(k)